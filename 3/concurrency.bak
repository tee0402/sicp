#lang sicp

; 123,132,213,231,312,321
; If forced to run sequentially, transactions can be reordered
; 123,213:45 ; 132:35 ; 231:50 ; 312,321:40
; If interleaved, transactions can be reordered and lost
; 1:110 ; 2:80 ; 3:50 ; 12,21:90 ; 13:55 ; 23:40, 31:60 ; 32:30

; 101, 121, 100

; 1000000: P1 then P2; P2 then P1
; 10000: First P1 access, P2, second P1 access; First and second P2 accesses, P1, third P2 access
; 100000: First P2 access, P1, second and third P2 accesses
; 100: P1 accesses, P2, P1 sets
; 1000: P2 accesses, P1, P2 sets
; Only 1000000 remains if serialized

; No because access is a single operation. Since the withdraw and deposit procedures both only have a single set, interleaving access
; within them will produce results that are the same as if the procedures were run sequentially

; Assuming that the serializer returns the same procedure during each call with the same procedure as the parameter, it is a safe change
; to make because then there would be no difference between the two versions

; If the exchanges are run sequentially, then the order of the balances is simply rearranged during each exchange
; The sum of the balances will be preserved because whatever we withdraw from one account, we always deposit back the same amount into
; another account

; There is no problem because the access and set! operations on each individual balance are contained within the serialized deposit
; and withdraw procedures, unlike in the exchange problem. This means that between the time when a balance is accessed and when a balance is
; set based on that accessed value the balance cannot have changed. That leaves the problem of not having enough money in the from-account
; to withdraw because another transfer occurred before the current transfer, which we assume is not a problem

; Louis is wrong because the serialized exchange would then call a withdraw in the same serialized set, which would cause a deadlock because
; the withdraw would need to wait for the exchange to finish first, but the exchange was the one that called withdraw, so it is waiting for
; the withdraw to finish

(define (make-mutex)
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) ; retry
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell) (set-car! cell false))
(define (test-and-set! cell)
  (if (car cell) true (begin (set-car! cell true) false)))

(define (make-semaphore n)
  (let ((semaphore (make-mutex-list n)))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
             (if (not (acquire semaphore))
                 (the-semaphore 'acquire)))
            ((eq? m 'release) (release semaphore))))
    the-semaphore))
(define (make-mutex-list n)
    (if (= n 0)
        '()
        (cons (make-mutex) (make-mutex-list (- n 1)))))
(define (acquire semaphore)
  )
(define (release semaphore)
  )